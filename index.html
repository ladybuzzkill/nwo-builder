<div id="nwo-builder"></div>

<style>
  /* â€”â€”â€” Layout & Style â€”â€”â€” */
  #nwo-builder { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.3; }
  .nwo-grid { display: grid; gap: 16px; grid-template-columns: 1fr; }
  @media (min-width: 1000px) {
    .nwo-grid { grid-template-columns: 300px 1fr; }
  }
  .card { border: 1px solid #ddd; border-radius: 12px; padding: 14px; background: #fff; }
  .card h3 { margin: 0 0 8px; font-size: 16px; }
  .muted { color: #555; font-size: 12px; }
  .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .row > * { margin: 4px 0; }
  label { font-size: 13px; }
  select, input[type="number"], button { font-size: 14px; padding: 6px 8px; }
  .pill { display: inline-flex; align-items: center; gap: 6px; border: 1px solid #ccc; border-radius: 999px; padding: 4px 10px; font-size: 12px; background: #fafafa; }
  .warn { color: #a40000; font-weight: 600; }
  .ok { color: #0a6; font-weight: 600; }
  .grid-2 { display: grid; gap: 12px; grid-template-columns: 1fr 1fr; }
  .stat-table { width: 100%; border-collapse: collapse; }
  .stat-table th, .stat-table td { padding: 6px 8px; border-bottom: 1px solid #eee; text-align: left; }
  .stat-table th { background: #f7f7f7; position: sticky; top: 0; z-index: 1; }
  .small { font-size: 12px; }
  .section { margin-top: 8px; }
  .tag { font-size: 11px; background: #eef6ff; color: #0b5; padding: 2px 6px; border-radius: 6px; border: 1px solid #cfe8ff; }
  details summary { cursor: pointer; }
  .dice { font-size: 28px; display: inline-block; width: 1.4em; text-align: center; transition: transform 200ms ease; }
  .shake { transform: rotate(6deg) scale(1.1); }
  .badgelite { background: #f2f2f2; border-radius: 6px; padding: 2px 6px; }
  .note { font-size: 12px; color: #333; background: #fff9e6; border: 1px solid #ffe7a3; border-radius: 8px; padding: 8px; }
</style>

<script>
(() => {
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
  // Data derived from your Dice Guide page
  // (Only traits with explicit, mechanical effects are wired.)
  // â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

  const BACKGROUNDS = {
    Scavenger: {
      traitPoints: 8, base: { STR: 8, FIT: 8 },
      freeTraits: [
        { name: "Outdoorsman", effects: {} }, // unaffected by weather (RP/mech outside dice)
        { name: "Keen Hearing", effects: { Perception: +2 } } // +2 Perception Rolls
      ]
    },
    Thinker: {
      traitPoints: 10, base: { STR: 8, FIT: 8 },
      freeTraits: [
        { name: "Dextrous", effects: {} },
        { name: "Fast Learner", effects: {} }
      ]
    },
    Stalwart: {
      traitPoints: 8, base: { STR: 10, FIT: 10 },
      freeTraits: [
        { name: "Fast Coagulation", effects: {} },
        { name: "Thick Skinned", effects: { Robustness: +2 } } // +2 Robustness Rolls
      ]
    },
    Labourer: {
      traitPoints: 8, base: { STR: 8, FIT: 8 },
      freeTraits: [
        { name: "Heavy Lifter", effects: { Robustness: +1 } }, // +1 Robustness Rolls
        { name: "Organized", effects: {} }
      ]
    }
  };

  // Vanilla traits with explicit dice effects from the page.
  const POSITIVE_TRAITS = [
    { name: "Speed Demon", cost: 1, effects: {} },
    { name: "Low Thirst", cost: 1, effects: {} },
    { name: "Herbalist", cost: 1, effects: {} },
    { name: "Iron Gut", cost: 1, effects: { Robustness: +1 } },
    { name: "Cats Eyes", cost: 2, effects: { Perception: +2 } },
    { name: "Adrenaline Junkie", cost: 2, effects: { Initiative: +2 } },
    { name: "Graceful", cost: 2, effects: { Stealth: +2 } },
    { name: "Brave", cost: 2, effects: { Resolve: +2 } },
    { name: "Inconspicuous", cost: 2, effects: { Stealth: +2 } },
    { name: "Fast Healer", cost: 2, effects: { Robustness: +1 } },
    { name: "Resilient", cost: 2, effects: {} },
    { name: "Fit", cost: 3, effects: {} },
    { name: "Strong", cost: 3, effects: {} },
    { name: "Eagle Eyed", cost: 3, effects: { "Ranged Attack": +1, Perception: +2 } },
    { name: "Desensitized", cost: 4, effects: { Resolve: +4 } },
  ];

  const NEGATIVE_TRAITS = [
    { name: "Prone to Illness", cost: 1, effects: { Robustness: -1 } },
    { name: "Smoker", cost: 1, effects: { Robustness: -1 } },
    { name: "Slow Driver", cost: 1, effects: {} },
    { name: "Slow Learner", cost: 1, effects: {} },
    { name: "Weak Stomach", cost: 1, effects: { Robustness: -1 } },
    { name: "Fear of Blood", cost: 2, effects: { Resolve: -2 } },
    { name: "Agoraphobic", cost: 2, effects: { Resolve: -2 } },
    { name: "All Thumbs", cost: 2, effects: {} },
    { name: "Claustrophobic", cost: 2, effects: { Resolve: -2 } },
    { name: "Cowardly", cost: 2, effects: { Resolve: -2 } },
    { name: "Pacifist", cost: 2, effects: { Initiative: -2 } },
    { name: "Short Sighted", cost: 2, effects: { "Ranged Attack": -1, Perception: -1 } },
    { name: "Thin Skinned", cost: 2, effects: { Robustness: -2 } },
    { name: "Conspicuous", cost: 2, effects: { Stealth: -2 } },
    { name: "Clumsy", cost: 2, effects: { Stealth: -2 } },
    { name: "Hard of Hearing", cost: 2, effects: { Perception: -2 } },
    { name: "Disorganized", cost: 3, effects: {} },
    { name: "Weak", cost: 3, effects: {} },
    { name: "Unfit", cost: 3, effects: {} },
    { name: "Illiterate", cost: 4, effects: {} },
    { name: "Deaf", cost: 4, effects: { Perception: -4 } },
    { name: "Very Weak", cost: 5, effects: { Resolve: +4 } },   // as listed
    { name: "Very Unfit", cost: 5, effects: { Resolve: +4 } },  // as listed
  ];

  // Skill trait tiers (cost/limits) and the skills they affect. Caps are implied by tier.
  const SKILL_TIERS = {
    Amateur: { cost: 1, start: 6, cap: 6, limitPerChar: Infinity },
    Experienced: { cost: 2, start: 8, cap: 8, limitPerChar: 2 },
    Expert: { cost: 3, start: 10, cap: 10, limitPerChar: 1 },
  };

  // Grouped skills per your page (amateur/experienced/expert variants share the same skill list but different bonus amounts).
  const SKILL_GROUPS = [
    { key: "Carpentry", label: "Carpentry", list: ["Carpentry"] },
    { key: "Farming", label: "Farming", list: ["Farming"] },
    { key: "First Aid", label: "First Aid", list: ["First Aid"] },
    { key: "Engineer", label: "Mechanics & Electronics", list: ["Mechanics","Electronics"] },
    { key: "Metalworking", label: "Metalworking", list: ["Metalworking"] },
    { key: "Housekeeper", label: "Cooking & Tailoring", list: ["Cooking","Tailoring"] },
    { key: "Shooter", label: "Aiming & Reloading", list: ["Aiming","Reloading"] },
    { key: "Outdoorsman", label: "Fishing/Foraging/Trapping", list: ["Fishing","Foraging","Trapping"] },
    { key: "Athlete", label: "Nimble & Sprinting", list: ["Nimble","Sprinting"] },
    { key: "Rogue", label: "Sneaking & Lightfooted", list: ["Sneaking","Lightfooted"] },
    { key: "Fighter-Survival", label: "Axe/Spear/Maintenance", list: ["Axe","Spear","Maintenance"] },
    { key: "Fighter-Blunt", label: "Long/Short Blunt + Maint.", list: ["Long Blunt","Short Blunt","Maintenance"] },
    { key: "Fighter-Blade", label: "Long/Short Blade + Maint.", list: ["Long Blade","Short Blade","Maintenance"] },
  ];

  // Map *some* skills to checks where level/2 becomes a modifier.
  // You can expand this mapping as you like.
  const SKILL_TO_CHECK = {
    Aiming: "Ranged Attack",
    Reloading: "Reloading",
    Sneaking: "Hiding",       // per table "Hiding" boosted by Sneaking; we expose Hiding as a roll
    Nimble: "Unarmed",        // per table; we include Unarmed roll
    "Long Blade": "Melee Attack",
    "Short Blade": "Melee Attack",
    "Long Blunt": "Melee Attack",
    "Short Blunt": "Melee Attack",
    Axe: "Melee Attack",
    Spear: "Melee Attack",
    Maintenance: null,
    Mechanics: null,
    Electronics: null,
    Metalworking: null,
    Cooking: null,
    Tailoring: null,
    Fishing: null,
    Foraging: null,
    Trapping: null,
    Sprinting: "Initiative", // if you prefer, remove this
    Lightfooted: "Stealth",
    FirstAid: null,
    Carpentry: null,
    Farming: null,
  };

  // Checks visible in the roller dropdown
  const CHECKS = [
    "Melee Attack", "Melee Defence", "Ranged Attack", "Reloading",
    "Perception", "Resolve", "Stealth", "Initiative", "Robustness",
    "Hiding", "Unarmed"
  ];

  // â€”â€”â€” State â€”â€”â€”
  const state = {
    background: "Scavenger",
    pos: new Set(),
    neg: new Set(),
    skills: {}, // key -> tier ("Amateur"/"Experienced"/"Expert")
  };

  // â€”â€”â€” Helpers â€”â€”â€”
  const el = (tag, props={}, ...children) => {
    const node = document.createElement(tag);
    Object.entries(props).forEach(([k,v]) => (k in node ? node[k]=v : node.setAttribute(k,v)));
    children.flat().forEach(c => node.append(c?.nodeType ? c : document.createTextNode(c)));
    return node;
  };

  const sumEffects = () => {
    const totals = { "Melee Attack":0, "Melee Defence":0, "Ranged Attack":0, Reloading:0,
      Perception:0, Resolve:0, Stealth:0, Initiative:0, Robustness:0, Hiding:0, Unarmed:0 };

    // Background freebies
    for (const t of BACKGROUNDS[state.background].freeTraits) {
      for (const [k,v] of Object.entries(t.effects)) totals[k] = (totals[k]||0)+v;
    }
    // Positive
    POSITIVE_TRAITS.forEach(t => { if (state.pos.has(t.name)) for (const [k,v] of Object.entries(t.effects)) totals[k]=(totals[k]||0)+v; });
    // Negative
    NEGATIVE_TRAITS.forEach(t => { if (state.neg.has(t.name)) for (const [k,v] of Object.entries(t.effects)) totals[k]=(totals[k]||0)+v; });

    // Skills â†’ modifiers = level/2
    for (const [groupKey, tier] of Object.entries(state.skills)) {
      const group = SKILL_GROUPS.find(g => g.key === groupKey);
      if (!group) continue;
      const { start } = SKILL_TIERS[tier];
      const mod = Math.floor(start / 2); // Skill Level Ã· 2
      group.list.forEach(skill => {
        const check = SKILL_TO_CHECK[skill] ?? null;
        if (check) totals[check] = (totals[check]||0) + mod;
      });
    }
    return totals;
  };

  const spend = () => {
    let pts = BACKGROUNDS[state.background].traitPoints;
    // pos +
    POSITIVE_TRAITS.forEach(t => { if (state.pos.has(t.name)) pts -= t.cost; });
    // neg -
    NEGATIVE_TRAITS.forEach(t => { if (state.neg.has(t.name)) pts += t.cost; });
    // skills +
    for (const tier of Object.values(state.skills)) pts -= SKILL_TIERS[tier].cost;
    return pts;
  };

  const skillTierCounts = () => {
    let exp=0, ex=0;
    for (const tier of Object.values(state.skills)) {
      if (tier==="Experienced") exp++;
      if (tier==="Expert") ex++;
    }
    return { exp, ex };
  };

  const illegalSkillMix = () => {
    // same group can't have two tiers
    // (UI enforces single select, but keep guard)
    return false;
  };

  // â€”â€”â€” UI â€”â€”â€”
  const root = document.getElementById("nwo-builder");
  const wrap = el("div", { className: "nwo-grid" });

  // Left column: selections
  const left = el("div", { className: "card" });
  left.append(el("h3",{}, "Character Builder"));

  // Background
  const bgCard = el("div", { className: "section" });
  bgCard.append(el("div", { className:"muted" }, "Background"));
  const bgSel = el("select", {});
  Object.keys(BACKGROUNDS).forEach(k => bgSel.append(el("option", { value: k }, k)));
  bgSel.value = state.background;
  const bgInfo = el("div", { className: "small badgelite" });
  const renderBgInfo = () => {
    const b = BACKGROUNDS[state.background];
    bgInfo.textContent = `${b.traitPoints} Trait Points â€¢ Base STR ${b.base.STR}, FIT ${b.base.FIT} â€¢ Free: ${b.freeTraits.map(x=>x.name).join(", ")}`;
  };
  renderBgInfo();
  bgSel.addEventListener("change", () => { state.background = bgSel.value; renderBgInfo(); renderAll(); });
  bgCard.append(el("div", { className:"row" }, bgSel, bgInfo));
  left.append(bgCard);

  // Positive traits
  const posCard = el("div", { className: "section" });
  posCard.append(el("div", { className:"muted" }, "Positive Traits"));
  const posList = el("div");
  POSITIVE_TRAITS.forEach(t => {
    const id = "pos_"+t.name.replace(/\s+/g,"_");
    const cb = el("input", { type:"checkbox", id });
    cb.addEventListener("change", () => { cb.checked ? state.pos.add(t.name) : state.pos.delete(t.name); renderAll(); });
    const label = el("label", { htmlFor:id }, `${t.name} (Cost ${t.cost})`);
    const eff = Object.keys(t.effects).length ? el("span",{className:"pill"}, "Effects: "+Object.entries(t.effects).map(([k,v])=>`${v>0?'+':''}${v} ${k}`).join(", ")) : el("span",{className:"pill"}, "No direct dice effect");
    posList.append(el("div",{className:"row"}, cb, label, eff));
  });
  posCard.append(posList);
  left.append(posCard);

  // Negative traits
  const negCard = el("div", { className: "section" });
  negCard.append(el("div", { className:"muted" }, "Negative Traits"));
  const negList = el("div");
  NEGATIVE_TRAITS.forEach(t => {
    const id = "neg_"+t.name.replace(/\s+/g,"_");
    const cb = el("input", { type:"checkbox", id });
    cb.addEventListener("change", () => { cb.checked ? state.neg.add(t.name) : state.neg.delete(t.name); renderAll(); });
    const label = el("label", { htmlFor:id }, `${t.name} (+${t.cost} points)`);
    const eff = Object.keys(t.effects).length ? el("span",{className:"pill"}, "Effects: "+Object.entries(t.effects).map(([k,v])=>`${v>0?'+':''}${v} ${k}`).join(", ")) : el("span",{className:"pill"}, "No direct dice effect");
    negList.append(el("div",{className:"row"}, cb, label, eff));
  });
  negCard.append(negList);
  left.append(negCard);

  // Skill traits
  const skillCard = el("div", { className: "section" });
  skillCard.append(el("div", { className:"muted" }, "Skill Traits (auto-set levels & caps; modifiers = level Ã· 2)"));
  const table = el("table", { className:"stat-table small" });
  const thead = el("thead");
  thead.append(el("tr",{},
    el("th",{},"Skill Group"),
    el("th",{},"Tier"),
    el("th",{},"Start"),
    el("th",{},"Cap"),
    el("th",{},"Cost"),
    el("th",{},"Affects")
  ));
  const tbody = el("tbody");
  SKILL_GROUPS.forEach(g => {
    const tr = el("tr");
    tr.append(el("td",{}, g.label));
    // tier selector
    const sel = el("select",{});
    sel.append(el("option",{value:""},"None"));
    ["Amateur","Experienced","Expert"].forEach(t => sel.append(el("option",{value:t},t)));
    sel.addEventListener("change", () => {
      if (sel.value) { state.skills[g.key] = sel.value; } else { delete state.skills[g.key]; }
      renderAll();
    });
    tr.append(el("td",{}, sel));
    tr.append(el("td",{}, el("span", { "data-start": g.key }, "-")));
    tr.append(el("td",{}, el("span", { "data-cap": g.key }, "-")));
    tr.append(el("td",{}, el("span", { "data-cost": g.key }, "-")));
    tr.append(el("td",{}, g.list.join(", ")));
    tbody.append(tr);
  });
  table.append(thead, tbody);
  skillCard.append(table);

  // Limits & points
  const pointsBar = el("div",{className:"row", style:"justify-content: space-between; margin-top:8px;"});
  const pointsLeft = el("div",{className:"pill"});
  const limitInfo = el("div",{className:"pill"});
  pointsBar.append(pointsLeft, limitInfo);
  skillCard.append(pointsBar);

  left.append(skillCard);

  // Right column: summary + roller
  const right = el("div", { className: "card" });

  // Totals panel
  const totalsCard = el("div", { className: "section" });
  totalsCard.append(el("h3",{},"Build Summary & Modifiers"));
  const totalsNote = el("div",{className:"note"},
    "Skill modifiers are computed as (Skill Level Ã· 2). For example, Level 6 â†’ +3; Level 10 â†’ +5. "
    +"Background freebies (e.g., Keen Hearing, Thick Skinned) and vanilla traits also add flat bonuses as listed on your Dice Guide."
  );
  totalsCard.append(totalsNote);

  const totalsTable = el("table", { className: "stat-table" });
  const th = el("thead");
  th.append(el("tr",{},
    el("th",{},"Check"),
    el("th",{},"Total Mod"),
    el("th",{},"From Traits"),
    el("th",{},"From Skills")
  ));
  const tb = el("tbody", { id:"totals-body" });
  totalsTable.append(th, tb);
  totalsCard.append(totalsTable);
  right.append(totalsCard);

  // Roller
  const roller = el("div", { className:"section" });
  roller.append(el("h3",{},"2d6 Test Roller"));
  const selCheck = el("select",{});
  CHECKS.forEach(c => selCheck.append(el("option",{value:c},c)));
  const rollBtn = el("button",{}, "Roll 2d6");
  const d1 = el("span",{className:"dice", title:"die 1"},"ðŸŽ²");
  const d2 = el("span",{className:"dice", title:"die 2"},"ðŸŽ²");
  const out = el("div",{className:"small", style:"margin-top:8px;"});
  roller.append(el("div",{className:"row"}, el("label",{},"Check:"), selCheck, rollBtn, d1, d2));
  roller.append(out);
  right.append(roller);

  // Links
  const links = el("div",{className:"section small muted"},
    "Reference: See the ",
    el("a",{href:"https://www.no-way-out.com/wiki/Dice_Guide", target:"_blank"},"Dice Guide"),
    " for background traits, vanilla trait effects, and skill trait tiers. Weapon tables & DIS exist but are beyond this builderâ€™s scope."
  );
  right.append(links);

  wrap.append(left, right);
  root.append(wrap);

  // â€”â€”â€” Renderers â€”â€”â€”
  function renderSkillRows() {
    // Update start/cap/cost cells per selected tier
    SKILL_GROUPS.forEach(g => {
      const startSpan = wrap.querySelector(`[data-start="${g.key}"]`);
      const capSpan   = wrap.querySelector(`[data-cap="${g.key}"]`);
      const costSpan  = wrap.querySelector(`[data-cost="${g.key}"]`);
      const tier = state.skills[g.key] || "";
      if (!tier) { startSpan.textContent="-"; capSpan.textContent="-"; costSpan.textContent="-"; }
      else {
        const T = SKILL_TIERS[tier];
        startSpan.textContent = T.start;
        capSpan.textContent   = T.cap;
        costSpan.textContent  = T.cost;
      }
    });

    const pts = spend();
    pointsLeft.textContent = `Remaining Trait Points: ${pts}`;
    pointsLeft.className = "pill " + (pts < 0 ? "warn" : "ok");

    const {exp, ex} = skillTierCounts();
    limitInfo.textContent = `Limits â€” Experienced: ${exp}/2 â€¢ Expert: ${ex}/1`;
    limitInfo.className = "pill " + ((exp>2 || ex>1 || pts<0 || illegalSkillMix()) ? "warn" : "ok");
  }

  function renderTotals() {
    const totals = sumEffects();

    // Decompose where bonuses come from (traits vs skills) for each check
    const traitOnly = {}; const skillOnly = {};
    CHECKS.forEach(k => { traitOnly[k]=0; skillOnly[k]=0; });

    // From background + vanilla traits
    const addEffects = (effects, bucket) => {
      for (const [k,v] of Object.entries(effects)) if (k in traitOnly) bucket[k]+=v;
    };

    BACKGROUNDS[state.background].freeTraits.forEach(t => addEffects(t.effects, traitOnly));
    POSITIVE_TRAITS.forEach(t => { if (state.pos.has(t.name)) addEffects(t.effects, traitOnly); });
    NEGATIVE_TRAITS.forEach(t => { if (state.neg.has(t.name)) addEffects(t.effects, traitOnly); });

    // From skills
    for (const [groupKey, tier] of Object.entries(state.skills)) {
      const group = SKILL_GROUPS.find(g => g.key === groupKey);
      if (!group) continue;
      const mod = Math.floor(SKILL_TIERS[tier].start / 2);
      group.list.forEach(skill => {
        const check = SKILL_TO_CHECK[skill] ?? null;
        if (check) skillOnly[check] += mod;
      });
    }

    // Build table
    const body = tb;
    body.innerHTML = "";
    CHECKS.forEach(check => {
      const tr = el("tr");
      tr.append(el("td",{}, check));
      tr.append(el("td",{}, (totals[check]||0)));
      tr.append(el("td",{}, traitOnly[check]||0));
      tr.append(el("td",{}, skillOnly[check]||0));
      body.append(tr);
    });
  }

  function renderAll() {
    renderSkillRows();
    renderTotals();
  }

  // Roller logic
  rollBtn.addEventListener("click", () => {
    const check = selCheck.value;
    const totals = sumEffects();
    const mod = totals[check] || 0;

    // roll with a tiny flourish
    d1.classList.add("shake"); d2.classList.add("shake");
    setTimeout(() => {
      d1.classList.remove("shake"); d2.classList.remove("shake");
      const r1 = 1 + Math.floor(Math.random()*6);
      const r2 = 1 + Math.floor(Math.random()*6);
      d1.textContent = r1; d2.textContent = r2;

      const total = r1 + r2 + mod;
      out.innerHTML =
        `<div><strong>${check}</strong> â†’ 2d6(${r1}+${r2}) ${mod>=0?'+':''}${mod} = <strong>${total}</strong></div>
         <div class="muted small">Breakdown: trait bonuses + skill modifiers (skill level Ã· 2) per the Dice Guide.</div>`;
    }, 180);
  });

  // Initial render
  renderAll();
})();
</script>

Add NWO Character Builder HTML for GitHub Pages
